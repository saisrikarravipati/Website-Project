
# --- Imports ---
from pyspark.sql import functions as F
import pandas as pd
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.application import MIMEApplication

# -----------------------------------------------------------------------------
# 1) Map TQ_CD -> Description (NO UDF; fast & Catalyst-friendly)
#    - Keep TQ_CD in the DF to avoid downstream unresolved-column surprises.
#    - Only select TEST_DESC for the email so the code never touches TQ_CD later.
# -----------------------------------------------------------------------------
tq_desc_map = {
    "TQ880": "Network Recon Validations",
    "TQ881": "Admin Fee Validations",
    "TQ882": "Bad Debt Validations",
    "TQ883": "Min Gtee Validations",
    "TQ884": "Network Access Fee Validations",
    "TQ885": "Specialty Cogs Validations",
}
# Convert the dict into a Spark map literal once (O(1) lookup in expression)
mapping_expr = F.create_map(*[x for kv in tq_desc_map.items() for x in (F.lit(kv[0]), F.lit(kv[1]))])

# Add TEST_DESC column; if code not in map, fallback to the code itself
ce_regression_summary_daily_result = (
    ce_regression_summary_daily_result
    .withColumn("TEST_DESC", F.coalesce(mapping_expr[F.col("TQ_CD")], F.col("TQ_CD")))
)
# (Intentionally NOT dropping TQ_CD; the email select below doesn't use it.)

# -----------------------------------------------------------------------------
# 2) Build the exact table to email (only columns we want to show)
#    - Guard on required columns to fail fast with a clear message if upstream changes.
# -----------------------------------------------------------------------------
COLUMNS = [
    "TEST_DESC", "TS_CTG", "PARENT_REQUEST_ID", "LOB", "APP_ID",
    "REQUEST_ID", "TASK_ID", "EXECUTION_STATUS", "TS_STATUS",
    "TOTAL_CNT", "SUCCESS_CNT", "FAILURE_CNT", "RUN_DATE_TS", "RUN_ID"
]

available_cols = set(ce_regression_summary_daily_result.columns)
missing_cols = [c for c in COLUMNS if c not in available_cols]
if missing_cols:
    raise ValueError(
        f"Missing columns before email select: {missing_cols}. "
        f"Available columns: {sorted(available_cols)}"
    )

email_df = (
    ce_regression_summary_daily_result
    .select(*COLUMNS)
    .orderBy(F.col("RUN_ID").desc())
    .limit(1000)   # safety cap for email size; adjust as needed
)

# -----------------------------------------------------------------------------
# 3) Convert to HTML + CSV for the email body/attachment
# -----------------------------------------------------------------------------
pdf = email_df.toPandas()
# Make timestamps readable for HTML
if "RUN_DATE_TS" in pdf.columns:
    pdf["RUN_DATE_TS"] = pdf["RUN_DATE_TS"].astype(str)

html_table = pdf.to_html(index=False, border=1, justify="center")
html_body = f"""
<html>
  <body>
    <h3>QAAP Daily Regression – Integrated Tests</h3>
    <p>Rows: {len(pdf)}</p>
    {html_table}
  </body>
</html>
"""
csv_bytes = pdf.to_csv(index=False).encode("utf-8")

# -----------------------------------------------------------------------------
# 4) Email helper: sends HTML body + CSV attachment
#    - If your relay disallows TLS, comment out server.starttls().
# -----------------------------------------------------------------------------
def send_email_df(
    recipients,
    subject,
    html_body,
    csv_bytes,
    csv_name="ce_regression_summary_daily_result.csv",
    sender="no-reply@cvshealth.com",
    smtp_host="smtpaz.corp.cvscaremark.com",
    smtp_port=25,
    use_starttls=True,
):
    msg = MIMEMultipart()
    msg["Subject"] = subject
    msg["From"] = sender
    msg["To"] = ", ".join(recipients)

    # HTML body
    msg.attach(MIMEText(html_body, "html"))

    # CSV attachment
    part = MIMEApplication(csv_bytes, Name=csv_name)
    part["Content-Disposition"] = f'attachment; filename="{csv_name}"'
    msg.attach(part)

    try:
        with smtplib.SMTP(smtp_host, smtp_port) as server:
            if use_starttls:
                try:
                    server.starttls()
                except Exception:
                    # Relay might not support TLS; continue without it
                    pass
            server.sendmail(sender, recipients, msg.as_string())
        print("Email sent successfully!")
    except Exception as e:
        print(f"Error sending email: {e}")

# -----------------------------------------------------------------------------
# 5) Send it
# -----------------------------------------------------------------------------
send_email_df(
    recipients=["you@cvshealth.com"],  # <-- update
    subject="QAAP Daily Regression – Integrated Tests",
    html_body=html_body,
    csv_bytes=csv_bytes
)
